---
layout: post
title: "Golang格式化输出"
date: 2017-08-31 17:30:00
image: ''
description: "Golang基础知识-格式化输出"
tags:
- Golang
categories:
- Chaz6chez

---

## 格式化输出

将 arg列表(参数列表) 中的 arg(参数) 转换为字符串输出

- 使用 **动词 v** 格式化 arg列表，**非字符串**元素之间添加空格

```golang
Print(arg列表)
```


- 使用 **动词 v** 格式化 arg 列表，**所有元素**之间添加空格，结尾添加换行符

```golang
Println(arg列表)
```

- 使用 **格式字符串** 格式化 arg 列表


```golang
Printf(格式字符串, arg列表)
```

**PS:** Print 类函数会返回已处理的 arg 数量和遇到的错误信息

## 格式化字符串
- 格式字符串由普通字符和占位符组成，例如：

```golang
abc%+ #8.3[3]vdef
```

- **其中 abc 和 def 是普通字符**，其它部分是占位符，占位符以 % 开头，以 **动词v** 结尾

```golang
%[旗标][宽度][.精度][arg索引]动词
```

**PS:**
- 方括号中的内容可以省略
- %% 将被转义为一个普通的 % 符号，这个不算开头


## 旗标
[[百度词条-旗标]](https://baike.baidu.com/item/%E6%97%97%E6%A0%87/1744877?fr=aladdin)

**+**   ：对于数值类型总是输出正负号（其它用法在动词部分说明）。
**-**   ：在右边进行宽度填充，而不是默认的左边。
**空格**：对于数值类型的正数，保留一个空白的符号位（其它用法在动词部分说明）。
**0**   ：用 0 进行宽度填充而不用空格，对于数值类型，符号将被移到所有 0 的前面。
**#**   ：相关用法在 **动词** 部分说明。

**PS:** "0" 和 "-" 不能同时使用，优先使用 "-" 而忽略 "0"。

## 宽度和精度
**宽度值**：用于设置最小宽度
**精度值**：对于浮点型，用于控制小数位数，对于字符串或字节数组，用于控制字符数量（不是字节数量）

“宽度”和“精度”都可以写成以下三种形式：

| 数值  |  *  | arg索引* |
|:---:|:---:|:------:|

**[ 数值 ]**： 表示使用指定的数值作为宽度值或精度值
**[ * ]**：表示使用当前正在处理的 arg 的值作为宽度值或精度值，如果这样的话，要格式化的 arg 将自动跳转到下一个
**[ arg索引 * ]**：表示使用指定 arg 的值作为宽度值或精度值，如果这样的话，要格式化的 arg 将自动跳转到指定 arg 的下一个

**PS:** 对于浮点型而言，动词 g/G 的精度值比较特殊，在适当的情况下，g/G 会设置总有效数字，而不是小数位数


## arg 索引

- **arg索引**: 由中括号和 arg 序号组成，如

```golang
# 其中的[3]，用于指定当前要处理的 arg 的序号，序号从 1 开始

abc%+ #8.3[3]vdef
```

```golang
'[' + arg序号 + ']'
```

## 动词

“动词”不能省略，不同的数据类型支持的动词不一样

### 通用动词

- **v**：默认格式，不同类型的默认格式如下：

| 布尔型 | 整形  | 浮点型 | 复数型 | 字符串 | 通　道 | 指　针 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|  t  |  d  |  g  |  g  |  s  |  p  |  p  |


- **#v**：默认格式，以符合 Go 语法的方式输出。特殊类型的 Go 语法格式如下：
无符号整型：x

- **T**：输出 arg 的类型而不是值（使用 Go 语法格式）。

### [布尔型]

- t：输出 true 或 false 字符串。

### [整型]

|     b/o/d      |        x/X        |          c          |                      q                       |                       U                        |
|:--------------:|:-----------------:|:-------------------:|:--------------------------------------------:|:----------------------------------------------:|
| 输出 2/8/10 进制格式 | 输出 16 进制格式（小写/大写） | 输出数值所表示的 Unicode 字符 | 输出数值所表示的 Unicode 字符（带单引号）。对于无法显示的字符，将输出其转义字符 | 输出 Unicode 码点（例如 U+1234，等同于字符串 "U+%04X" 的显示结果） |

- 对于 o/x/X，如果使用 "#" 旗标，则会添加前导 0 或 0x。
- 对于 U，如果使用 "#" 旗标，则会在 Unicode 码点后面添加相应的 '字符'（前提是该字符必须可显示）

### [浮点型和复数型]

|       b        |           e/E            |      f/F      |                g/G                |
|:--------------:|:------------------------:|:-------------:|:---------------------------------:|
| 科学计数法（以 2  为底） | 科学计数法（以 10 为底，小写 e/大写 E） | 普通小数格式（两者无区别） | 大指数（指数 >= 6）使用 %e/%E，其它情况使用 %f/%F |

### [字符串或字节切片]

|   s   |        q         |              x/X               |
|:-----:|:----------------:|:------------------------------:|
| 普通字符串 | 双引号引起来的 Go 语法字符串 | 十六进制编码（小写/大写，以字节为元素进行编码，而不是字符） |

**对于 q：**
- 如果使用了 "+" 旗标，则将所有非 ASCII 字符都进行转义处理
- 如果使用了 "#" 旗标，则输出反引号引起来的字符串（前提是
- 字符串中不包含任何制表符以外的控制字符，否则忽略 # 旗标）

**对于 x/X：**
- 如果使用了 " " 旗标，则在每个元素之间添加空格
- 如果使用了 "#" 旗标，则在十六进制格式之前添加 0x 前缀

### [指针类型]

|        p        |        #p        |
|:---------------:|:----------------:|
| 带 0x 前缀的十六进制地址值 | 不带 0x 前缀的十六进制地址值 |

### [符合类型]

复合类型将使用不同的格式输出，格式如下：

**结构体：**{字段1 字段2 ...}
**数组或切片：**[元素0 元素1 ...]
**映射：**map[键1:值1 键2:值2 ...]
**指向符合元素的指针：**&{}, &[], &map[]

**PS：**
- 复合类型本身没有动词，动词将应用到复合类型的元素上
- 结构体可以使用  **+v**  同时输出字段名。

#### 代码示例

```golang
package main

import "fmt"

func main() {
	// 旗标、宽度、精度、索引
	fmt.Printf("|%0+- #[1]*.[2]*[3]d|%0+- #[1]*.[2]*[4]d|\n", 8, 4, 32, 64)

	// 浮点型精度
	fmt.Printf("|%f|%8.4f|%8.f|%.4f|%.f|\n", 3.2, 3.2, 3.2, 3.2, 3.2)
	fmt.Printf("|%.3f|%.3g|\n", 12.345678, 12.345678)
	fmt.Printf("|%.2f|\n", 12.345678+12.345678i)

	// 字符串精度
	s := "你好世界！"
	fmt.Printf("|%s|%8.2s|%8.s|%.2s|%.s|\n", s, s, s, s, s)
	fmt.Printf("|%x|%8.2x|%8.x|%.2x|%.x|\n", s, s, s, s, s)

	// 带引号字符串
	s1 := "Hello 世界!"       // CanBackquote
	s2 := "Hello\n世界!"      // !CanBackquote
	fmt.Printf("%q\n", s1)  // 双引号
	fmt.Printf("%#q\n", s1) // 反引号成功
	fmt.Printf("%#q\n", s2) // 反引号失败
	fmt.Printf("%+q\n", s2) // 仅包含 ASCII 字符

	// Unicode 码点
	fmt.Printf("%U, %#U\n", '好', '好')
	fmt.Printf("%U, %#U\n", '\n', '\n')

	// 接口类型将输出其内部包含的值
	var i interface{} = struct {
		name string
		age  int
	}{"AAA", 20}
	fmt.Printf("%v\n", i)  // 只输出字段值
	fmt.Printf("%+v\n", i) // 同时输出字段名
	fmt.Printf("%#v\n", i) // Go 语法格式

	// 输出类型
	fmt.Printf("%T\n", i)
}
```

# 注意

- 如果 arg 是一个反射值，则该 arg 将被它所持有的具体值所取代。

- 如果 arg 实现了 Formatter 接口，将调用它的 Format 方法完成格式化。

- 如果 v 动词使用了 # 旗标（%#v），并且 arg 实现了 GoStringer 接口，将调用它的 GoString 方法完成格式化。

**如果格式化操作指定了字符串相关的动词（比如 %s、%q、%v、%x、%X），接下来的两条规则将适用：**

- 如果 arg 实现了 error 接口，将调用它的 Error 方法完成格式化。

- 如果 arg 实现了 string 接口，将调用它的 String 方法完成格式化。

**在实现格式化相关接口的时候，要避免无限递归的情况，比如：**

```golang
type X string

/*
func (x X) String() string {
	return Sprintf("<%s>", x)
}
*/

//在格式化之前，要先转换数据类型，这样就可以避免无限递归：

func (x X) String() string {
	return Sprintf("<%s>", string(x))
}
```

**无限递归也可能发生在自引用数据类型上面，比如一个切片的元素引用了切片自身。
这种情况比较罕见，比如：**

```golang
a := make([]interface{}, 1)
a[0] = a
fmt.Println(a)
```